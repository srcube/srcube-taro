diff --git a/dist/config.d.ts b/dist/config.d.ts
index cd8e28b317c27837ec58552db42d317935b5f3f7..d66798115d33c67cfc020d4e7a2efa3d6a41b43f 100644
--- a/dist/config.d.ts
+++ b/dist/config.d.ts
@@ -1,4 +1,4 @@
-import type {extendTailwindMerge} from "tailwind-merge";
+import type {extendTailwindMerge, ClassNameValue} from "tailwind-merge";
 
 type MergeConfig = Parameters<typeof extendTailwindMerge>[0];
 type LegacyMergeConfig = Extract<MergeConfig, {extend?: unknown}>["extend"];
@@ -16,6 +16,12 @@ export type TWMConfig = {
    * @see https://github.com/dcastil/tailwind-merge/blob/v2.2.0/docs/configuration.md
    */
   twMergeConfig?: MergeConfig & LegacyMergeConfig;
+  /**
+   * Custom twMerge function to use instead of the default one.
+   * This allows you to use a pre-configured twMerge instance.
+   * Should have the same signature as twMerge: (...inputs: ClassNameValue[]) => string
+   */
+  twMergeFn?: (...inputs: ClassNameValue[]) => string;
 };
 
 export type TVConfig = TWMConfig;
diff --git a/dist/index.cjs b/dist/index.cjs
index f2dc5a6c53d8cefc1b7efd673ceb101f46214b9a..b2c7e58d2d9207d00de5d6326dee57d4cce453f5 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -1 +1 @@
-'use strict';var tailwindMerge=require('tailwind-merge');var q=e=>typeof e=="boolean"?`${e}`:e===0?"0":e,g=e=>!e||typeof e!="object"||Object.keys(e).length===0,X=(e,l)=>JSON.stringify(e)===JSON.stringify(l);function Y(e,l){e.forEach(function(t){Array.isArray(t)?Y(t,l):l.push(t);});}function F(e){let l=[];return Y(e,l),l}var J=(...e)=>F(e).filter(Boolean),T=(e,l)=>{let t={},O=Object.keys(e),k=Object.keys(l);for(let y of O)if(k.includes(y)){let V=e[y],h=l[y];Array.isArray(V)||Array.isArray(h)?t[y]=J(h,V):typeof V=="object"&&typeof h=="object"?t[y]=T(V,h):t[y]=h+" "+V;}else t[y]=e[y];for(let y of k)O.includes(y)||(t[y]=l[y]);return t},R=e=>!e||typeof e!="string"?e:e.replace(/\s+/g," ").trim();var ce={twMerge:!0,twMergeConfig:{},responsiveVariants:!1},_=e=>e||void 0,E=(...e)=>_(F(e).filter(Boolean).join(" ")),U=null,C={},W=!1,S=(...e)=>l=>l.twMerge?((!U||W)&&(W=!1,U=g(C)?tailwindMerge.twMerge:tailwindMerge.extendTailwindMerge({...C,extend:{theme:C.theme,classGroups:C.classGroups,conflictingClassGroupModifiers:C.conflictingClassGroupModifiers,conflictingClassGroups:C.conflictingClassGroups,...C.extend}})),_(U(E(e)))):E(e),Z=(e,l)=>{for(let t in l)e.hasOwnProperty(t)?e[t]=E(e[t],l[t]):e[t]=l[t];return e},oe=(e,l)=>{let{extend:t=null,slots:O={},variants:k={},compoundVariants:y=[],compoundSlots:V=[],defaultVariants:h={}}=e,d={...ce,...l},B=t!=null&&t.base?E(t.base,e==null?void 0:e.base):e==null?void 0:e.base,b=t!=null&&t.variants&&!g(t.variants)?T(k,t.variants):k,N=t!=null&&t.defaultVariants&&!g(t.defaultVariants)?{...t.defaultVariants,...h}:h;!g(d.twMergeConfig)&&!X(d.twMergeConfig,C)&&(W=!0,C=d.twMergeConfig);let $=g(t==null?void 0:t.slots),x=g(O)?{}:{base:E(e==null?void 0:e.base,$&&(t==null?void 0:t.base)),...O},M=$?x:Z({...t==null?void 0:t.slots},g(x)?{base:e==null?void 0:e.base}:x),j=g(t==null?void 0:t.compoundVariants)?y:J(t==null?void 0:t.compoundVariants,y),v=f=>{if(g(b)&&g(O)&&$)return S(B,f==null?void 0:f.class,f==null?void 0:f.className)(d);if(j&&!Array.isArray(j))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof j}`);if(V&&!Array.isArray(V))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V}`);let P=(r,a,n=[],i)=>{let s=n;if(typeof a=="string")s=s.concat(R(a).split(" ").map(o=>`${r}:${o}`));else if(Array.isArray(a))s=s.concat(a.reduce((o,c)=>o.concat(`${r}:${c}`),[]));else if(typeof a=="object"&&typeof i=="string"){for(let o in a)if(a.hasOwnProperty(o)&&o===i){let c=a[o];if(c&&typeof c=="string"){let m=R(c);s[i]?s[i]=s[i].concat(m.split(" ").map(u=>`${r}:${u}`)):s[i]=m.split(" ").map(u=>`${r}:${u}`);}else Array.isArray(c)&&c.length>0&&(s[i]=c.reduce((m,u)=>m.concat(`${r}:${u}`),[]));}}return s},z=(r,a=b,n=null,i=null)=>{var L;let s=a[r];if(!s||g(s))return null;let o=(L=i==null?void 0:i[r])!=null?L:f==null?void 0:f[r];if(o===null)return null;let c=q(o),m=Array.isArray(d.responsiveVariants)&&d.responsiveVariants.length>0||d.responsiveVariants===!0,u=N==null?void 0:N[r],A=[];if(typeof c=="object"&&m)for(let[G,Q]of Object.entries(c)){let ae=s[Q];if(G==="initial"){u=Q;continue}Array.isArray(d.responsiveVariants)&&!d.responsiveVariants.includes(G)||(A=P(G,ae,A,n));}let p=c!=null&&typeof c!="object"?c:q(u),w=s[p||"false"];return typeof A=="object"&&typeof n=="string"&&A[n]?Z(A,w):A.length>0?(A.push(w),n==="base"?A.join(" "):A):w},ee=()=>b?Object.keys(b).map(r=>z(r,b)):null,te=(r,a)=>{if(!b||typeof b!="object")return null;let n=new Array;for(let i in b){let s=z(i,b,r,a),o=r==="base"&&typeof s=="string"?s:s&&s[r];o&&(n[n.length]=o);}return n},D={};for(let r in f)f[r]!==void 0&&(D[r]=f[r]);let H=(r,a)=>{var i;let n=typeof(f==null?void 0:f[r])=="object"?{[r]:(i=f[r])==null?void 0:i.initial}:{};return {...N,...D,...n,...a}},I=(r=[],a)=>{let n=[];for(let{class:i,className:s,...o}of r){let c=!0;for(let[m,u]of Object.entries(o)){let A=H(m,a)[m];if(Array.isArray(u)){if(!u.includes(A)){c=!1;break}}else {let p=w=>w==null||w===!1;if(p(u)&&p(A))continue;if(A!==u){c=!1;break}}}c&&(i&&n.push(i),s&&n.push(s));}return n},ne=r=>{let a=I(j,r);if(!Array.isArray(a))return a;let n={};for(let i of a)if(typeof i=="string"&&(n.base=S(n.base,i)(d)),typeof i=="object")for(let[s,o]of Object.entries(i))n[s]=S(n[s],o)(d);return n},re=r=>{if(V.length<1)return null;let a={};for(let{slots:n=[],class:i,className:s,...o}of V){if(!g(o)){let c=!0;for(let m of Object.keys(o)){let u=H(m,r)[m];if(u===void 0||(Array.isArray(o[m])?!o[m].includes(u):o[m]!==u)){c=!1;break}}if(!c)continue}for(let c of n)a[c]=a[c]||[],a[c].push([i,s]);}return a};if(!g(O)||!$){let r={};if(typeof M=="object"&&!g(M))for(let a of Object.keys(M))r[a]=n=>{var i,s;return S(M[a],te(a,n),((i=ne(n))!=null?i:[])[a],((s=re(n))!=null?s:[])[a],n==null?void 0:n.class,n==null?void 0:n.className)(d)};return r}return S(B,ee(),I(j),f==null?void 0:f.class,f==null?void 0:f.className)(d)},K=()=>{if(!(!b||typeof b!="object"))return Object.keys(b)};return v.variantKeys=K(),v.extend=t,v.base=B,v.slots=M,v.variants=b,v.defaultVariants=N,v.compoundSlots=V,v.compoundVariants=j,v},ye=e=>(l,t)=>oe(l,t?T(e,t):e);exports.cn=S;exports.cnBase=E;exports.createTV=ye;exports.defaultConfig=ce;exports.tv=oe;exports.voidEmpty=_;
\ No newline at end of file
+'use strict';var tailwindMerge=require('tailwind-merge');var G=e=>typeof e=="boolean"?`${e}`:e===0?"0":e,g=e=>!e||typeof e!="object"||Object.keys(e).length===0,Y=(e,o)=>JSON.stringify(e)===JSON.stringify(o);function Z(e,o){e.forEach(function(t){Array.isArray(t)?Z(t,o):o.push(t);});}function q(e){let o=[];return Z(e,o),o}var J=(...e)=>q(e).filter(Boolean),T=(e,o)=>{let t={},V=Object.keys(e),k=Object.keys(o);for(let y of V)if(k.includes(y)){let w=e[y],M=o[y];Array.isArray(w)||Array.isArray(M)?t[y]=J(M,w):typeof w=="object"&&typeof M=="object"?t[y]=T(w,M):t[y]=M+" "+w;}else t[y]=e[y];for(let y of k)V.includes(y)||(t[y]=o[y]);return t},R=e=>!e||typeof e!="string"?e:e.replace(/\s+/g," ").trim();var ce={twMerge:!0,twMergeConfig:{},responsiveVariants:!1},W=e=>e||void 0,j=(...e)=>W(q(e).filter(Boolean).join(" ")),U=null,v={},z=!1,E=(...e)=>o=>o.twMerge?o.twMergeFn?W(o.twMergeFn(j(e))):((!U||z)&&(z=!1,U=g(v)?tailwindMerge.twMerge:tailwindMerge.extendTailwindMerge({...v,extend:{theme:v.theme,classGroups:v.classGroups,conflictingClassGroupModifiers:v.conflictingClassGroupModifiers,conflictingClassGroups:v.conflictingClassGroups,...v.extend}})),W(U(j(e)))):j(e),_=(e,o)=>{for(let t in o)e.hasOwnProperty(t)?e[t]=j(e[t],o[t]):e[t]=o[t];return e},oe=(e,o)=>{let{extend:t=null,slots:V={},variants:k={},compoundVariants:y=[],compoundSlots:w=[],defaultVariants:M={}}=e,d={...ce,...o},p=t!=null&&t.base?j(t.base,e==null?void 0:e.base):e==null?void 0:e.base,b=t!=null&&t.variants&&!g(t.variants)?T(k,t.variants):k,N=t!=null&&t.defaultVariants&&!g(t.defaultVariants)?{...t.defaultVariants,...M}:M;!g(d.twMergeConfig)&&!Y(d.twMergeConfig,v)&&(z=!0,v=d.twMergeConfig);let $=g(t==null?void 0:t.slots),B=g(V)?{}:{base:j(e==null?void 0:e.base,$&&(t==null?void 0:t.base)),...V},S=$?B:_({...t==null?void 0:t.slots},g(B)?{base:e==null?void 0:e.base}:B),h=g(t==null?void 0:t.compoundVariants)?y:J(t==null?void 0:t.compoundVariants,y),C=l=>{if(g(b)&&g(V)&&$)return E(p,l==null?void 0:l.class,l==null?void 0:l.className)(d);if(h&&!Array.isArray(h))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h}`);if(w&&!Array.isArray(w))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof w}`);let P=(n,a,r=[],i)=>{let s=r;if(typeof a=="string")s=s.concat(R(a).split(" ").map(f=>`${n}:${f}`));else if(Array.isArray(a))s=s.concat(a.reduce((f,c)=>f.concat(`${n}:${c}`),[]));else if(typeof a=="object"&&typeof i=="string"){for(let f in a)if(a.hasOwnProperty(f)&&f===i){let c=a[f];if(c&&typeof c=="string"){let m=R(c);s[i]?s[i]=s[i].concat(m.split(" ").map(u=>`${n}:${u}`)):s[i]=m.split(" ").map(u=>`${n}:${u}`);}else Array.isArray(c)&&c.length>0&&(s[i]=c.reduce((m,u)=>m.concat(`${n}:${u}`),[]));}}return s},D=(n,a=b,r=null,i=null)=>{var Q;let s=a[n];if(!s||g(s))return null;let f=(Q=i==null?void 0:i[n])!=null?Q:l==null?void 0:l[n];if(f===null)return null;let c=G(f),m=Array.isArray(d.responsiveVariants)&&d.responsiveVariants.length>0||d.responsiveVariants===!0,u=N==null?void 0:N[n],A=[];if(typeof c=="object"&&m)for(let[x,X]of Object.entries(c)){let ae=s[X];if(x==="initial"){u=X;continue}Array.isArray(d.responsiveVariants)&&!d.responsiveVariants.includes(x)||(A=P(x,ae,A,r));}let F=c!=null&&typeof c!="object"?c:G(u),O=s[F||"false"];return typeof A=="object"&&typeof r=="string"&&A[r]?_(A,O):A.length>0?(A.push(O),r==="base"?A.join(" "):A):O},ee=()=>b?Object.keys(b).map(n=>D(n,b)):null,te=(n,a)=>{if(!b||typeof b!="object")return null;let r=new Array;for(let i in b){let s=D(i,b,n,a),f=n==="base"&&typeof s=="string"?s:s&&s[n];f&&(r[r.length]=f);}return r},H={};for(let n in l)l[n]!==void 0&&(H[n]=l[n]);let I=(n,a)=>{var i;let r=typeof(l==null?void 0:l[n])=="object"?{[n]:(i=l[n])==null?void 0:i.initial}:{};return {...N,...H,...r,...a}},L=(n=[],a)=>{let r=[];for(let{class:i,className:s,...f}of n){let c=!0;for(let[m,u]of Object.entries(f)){let A=I(m,a)[m];if(Array.isArray(u)){if(!u.includes(A)){c=!1;break}}else {let F=O=>O==null||O===!1;if(F(u)&&F(A))continue;if(A!==u){c=!1;break}}}c&&(i&&r.push(i),s&&r.push(s));}return r},re=n=>{let a=L(h,n);if(!Array.isArray(a))return a;let r={};for(let i of a)if(typeof i=="string"&&(r.base=E(r.base,i)(d)),typeof i=="object")for(let[s,f]of Object.entries(i))r[s]=E(r[s],f)(d);return r},ne=n=>{if(w.length<1)return null;let a={};for(let{slots:r=[],class:i,className:s,...f}of w){if(!g(f)){let c=!0;for(let m of Object.keys(f)){let u=I(m,n)[m];if(u===void 0||(Array.isArray(f[m])?!f[m].includes(u):f[m]!==u)){c=!1;break}}if(!c)continue}for(let c of r)a[c]=a[c]||[],a[c].push([i,s]);}return a};if(!g(V)||!$){let n={};if(typeof S=="object"&&!g(S))for(let a of Object.keys(S))n[a]=r=>{var i,s;return E(S[a],te(a,r),((i=re(r))!=null?i:[])[a],((s=ne(r))!=null?s:[])[a],r==null?void 0:r.class,r==null?void 0:r.className)(d)};return n}return E(p,ee(),L(h),l==null?void 0:l.class,l==null?void 0:l.className)(d)},K=()=>{if(!(!b||typeof b!="object"))return Object.keys(b)};return C.variantKeys=K(),C.extend=t,C.base=p,C.slots=S,C.variants=b,C.defaultVariants=N,C.compoundSlots=w,C.compoundVariants=h,C},ye=e=>(o,t)=>{let V=t?T(e,t):e;return t!=null&&t.twMergeFn?V.twMergeFn=t.twMergeFn:e.twMergeFn&&!V.twMergeFn&&(V.twMergeFn=e.twMergeFn),oe(o,V)};exports.cn=E;exports.cnBase=j;exports.createTV=ye;exports.defaultConfig=ce;exports.tv=oe;exports.voidEmpty=W;
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index b6d6fd4be224e6b5e23f5f2e1e42799dd50bfd0f..1f2584f8af717ee5153d0c0e058d75f0d10c9a25 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1 +1 @@
-import {e,b,g,c,f,a,h}from'./chunk-I2QGXAA3.js';import {twMerge,extendTailwindMerge}from'tailwind-merge';var ie={twMerge:!0,twMergeConfig:{},responsiveVariants:!1},x=s=>s||void 0,N=(...s)=>x(e(s).filter(Boolean).join(" ")),R=null,v={},q=!1,M=(...s)=>b$1=>b$1.twMerge?((!R||q)&&(q=!1,R=b(v)?twMerge:extendTailwindMerge({...v,extend:{theme:v.theme,classGroups:v.classGroups,conflictingClassGroupModifiers:v.conflictingClassGroupModifiers,conflictingClassGroups:v.conflictingClassGroups,...v.extend}})),x(R(N(s)))):N(s),_=(s,b)=>{for(let e in b)s.hasOwnProperty(e)?s[e]=N(s[e],b[e]):s[e]=b[e];return s},ce=(s,b$1)=>{let{extend:e=null,slots:O={},variants:U={},compoundVariants:W=[],compoundSlots:C=[],defaultVariants:z={}}=s,m={...ie,...b$1},k=e!=null&&e.base?N(e.base,s==null?void 0:s.base):s==null?void 0:s.base,g$1=e!=null&&e.variants&&!b(e.variants)?g(U,e.variants):U,w=e!=null&&e.defaultVariants&&!b(e.defaultVariants)?{...e.defaultVariants,...z}:z;!b(m.twMergeConfig)&&!c(m.twMergeConfig,v)&&(q=!0,v=m.twMergeConfig);let S=b(e==null?void 0:e.slots),T=b(O)?{}:{base:N(s==null?void 0:s.base,S&&(e==null?void 0:e.base)),...O},j=S?T:_({...e==null?void 0:e.slots},b(T)?{base:s==null?void 0:s.base}:T),h$1=b(e==null?void 0:e.compoundVariants)?W:f(e==null?void 0:e.compoundVariants,W),V=l=>{if(b(g$1)&&b(O)&&S)return M(k,l==null?void 0:l.class,l==null?void 0:l.className)(m);if(h$1&&!Array.isArray(h$1))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);if(C&&!Array.isArray(C))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);let P=(a,n,t=[],i)=>{let r=t;if(typeof n=="string")r=r.concat(h(n).split(" ").map(o=>`${a}:${o}`));else if(Array.isArray(n))r=r.concat(n.reduce((o,c)=>o.concat(`${a}:${c}`),[]));else if(typeof n=="object"&&typeof i=="string"){for(let o in n)if(n.hasOwnProperty(o)&&o===i){let c=n[o];if(c&&typeof c=="string"){let u=h(c);r[i]?r[i]=r[i].concat(u.split(" ").map(f=>`${a}:${f}`)):r[i]=u.split(" ").map(f=>`${a}:${f}`);}else Array.isArray(c)&&c.length>0&&(r[i]=c.reduce((u,f)=>u.concat(`${a}:${f}`),[]));}}return r},D=(a$1,n=g$1,t=null,i=null)=>{var L;let r=n[a$1];if(!r||b(r))return null;let o=(L=i==null?void 0:i[a$1])!=null?L:l==null?void 0:l[a$1];if(o===null)return null;let c=a(o),u=Array.isArray(m.responsiveVariants)&&m.responsiveVariants.length>0||m.responsiveVariants===!0,f=w==null?void 0:w[a$1],d=[];if(typeof c=="object"&&u)for(let[E,Q]of Object.entries(c)){let ne=r[Q];if(E==="initial"){f=Q;continue}Array.isArray(m.responsiveVariants)&&!m.responsiveVariants.includes(E)||(d=P(E,ne,d,t));}let $=c!=null&&typeof c!="object"?c:a(f),A=r[$||"false"];return typeof d=="object"&&typeof t=="string"&&d[t]?_(d,A):d.length>0?(d.push(A),t==="base"?d.join(" "):d):A},p=()=>g$1?Object.keys(g$1).map(a=>D(a,g$1)):null,ee=(a,n)=>{if(!g$1||typeof g$1!="object")return null;let t=new Array;for(let i in g$1){let r=D(i,g$1,a,n),o=a==="base"&&typeof r=="string"?r:r&&r[a];o&&(t[t.length]=o);}return t},H={};for(let a in l)l[a]!==void 0&&(H[a]=l[a]);let I=(a,n)=>{var i;let t=typeof(l==null?void 0:l[a])=="object"?{[a]:(i=l[a])==null?void 0:i.initial}:{};return {...w,...H,...t,...n}},J=(a=[],n)=>{let t=[];for(let{class:i,className:r,...o}of a){let c=!0;for(let[u,f]of Object.entries(o)){let d=I(u,n)[u];if(Array.isArray(f)){if(!f.includes(d)){c=!1;break}}else {let $=A=>A==null||A===!1;if($(f)&&$(d))continue;if(d!==f){c=!1;break}}}c&&(i&&t.push(i),r&&t.push(r));}return t},te=a=>{let n=J(h$1,a);if(!Array.isArray(n))return n;let t={};for(let i of n)if(typeof i=="string"&&(t.base=M(t.base,i)(m)),typeof i=="object")for(let[r,o]of Object.entries(i))t[r]=M(t[r],o)(m);return t},ae=a=>{if(C.length<1)return null;let n={};for(let{slots:t=[],class:i,className:r,...o}of C){if(!b(o)){let c=!0;for(let u of Object.keys(o)){let f=I(u,a)[u];if(f===void 0||(Array.isArray(o[u])?!o[u].includes(f):o[u]!==f)){c=!1;break}}if(!c)continue}for(let c of t)n[c]=n[c]||[],n[c].push([i,r]);}return n};if(!b(O)||!S){let a={};if(typeof j=="object"&&!b(j))for(let n of Object.keys(j))a[n]=t=>{var i,r;return M(j[n],ee(n,t),((i=te(t))!=null?i:[])[n],((r=ae(t))!=null?r:[])[n],t==null?void 0:t.class,t==null?void 0:t.className)(m)};return a}return M(k,p(),J(h$1),l==null?void 0:l.class,l==null?void 0:l.className)(m)},K=()=>{if(!(!g$1||typeof g$1!="object"))return Object.keys(g$1)};return V.variantKeys=K(),V.extend=e,V.base=k,V.slots=j,V.variants=g$1,V.defaultVariants=w,V.compoundSlots=C,V.compoundVariants=h$1,V},fe=s=>(b,e)=>ce(b,e?g(s,e):s);export{M as cn,N as cnBase,fe as createTV,ie as defaultConfig,ce as tv,x as voidEmpty};
\ No newline at end of file
+import {e,b,g,c,f,a,h}from'./chunk-I2QGXAA3.js';import {twMerge,extendTailwindMerge}from'tailwind-merge';var ie={twMerge:!0,twMergeConfig:{},responsiveVariants:!1},q=n=>n||void 0,A=(...n)=>q(e(n).filter(Boolean).join(" ")),R=null,C={},U=!1,O=(...n)=>b$1=>b$1.twMerge?b$1.twMergeFn?q(b$1.twMergeFn(A(n))):((!R||U)&&(U=!1,R=b(C)?twMerge:extendTailwindMerge({...C,extend:{theme:C.theme,classGroups:C.classGroups,conflictingClassGroupModifiers:C.conflictingClassGroupModifiers,conflictingClassGroups:C.conflictingClassGroups,...C.extend}})),q(R(A(n)))):A(n),x=(n,b)=>{for(let e in b)n.hasOwnProperty(e)?n[e]=A(n[e],b[e]):n[e]=b[e];return n},ce=(n,b$1)=>{let{extend:e=null,slots:V={},variants:W={},compoundVariants:z=[],compoundSlots:v=[],defaultVariants:D={}}=n,y={...ie,...b$1},k=e!=null&&e.base?A(e.base,n==null?void 0:n.base):n==null?void 0:n.base,g$1=e!=null&&e.variants&&!b(e.variants)?g(W,e.variants):W,j=e!=null&&e.defaultVariants&&!b(e.defaultVariants)?{...e.defaultVariants,...D}:D;!b(y.twMergeConfig)&&!c(y.twMergeConfig,C)&&(U=!0,C=y.twMergeConfig);let S=b(e==null?void 0:e.slots),F=b(V)?{}:{base:A(n==null?void 0:n.base,S&&(e==null?void 0:e.base)),...V},N=S?F:x({...e==null?void 0:e.slots},b(F)?{base:n==null?void 0:n.base}:F),M=b(e==null?void 0:e.compoundVariants)?z:f(e==null?void 0:e.compoundVariants,z),w=f=>{if(b(g$1)&&b(V)&&S)return O(k,f==null?void 0:f.class,f==null?void 0:f.className)(y);if(M&&!Array.isArray(M))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof M}`);if(v&&!Array.isArray(v))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof v}`);let P=(a,r,t=[],i)=>{let s=t;if(typeof r=="string")s=s.concat(h(r).split(" ").map(l=>`${a}:${l}`));else if(Array.isArray(r))s=s.concat(r.reduce((l,c)=>l.concat(`${a}:${c}`),[]));else if(typeof r=="object"&&typeof i=="string"){for(let l in r)if(r.hasOwnProperty(l)&&l===i){let c=r[l];if(c&&typeof c=="string"){let u=h(c);s[i]?s[i]=s[i].concat(u.split(" ").map(o=>`${a}:${o}`)):s[i]=u.split(" ").map(o=>`${a}:${o}`);}else Array.isArray(c)&&c.length>0&&(s[i]=c.reduce((u,o)=>u.concat(`${a}:${o}`),[]));}}return s},H=(a$1,r=g$1,t=null,i=null)=>{var Q;let s=r[a$1];if(!s||b(s))return null;let l=(Q=i==null?void 0:i[a$1])!=null?Q:f==null?void 0:f[a$1];if(l===null)return null;let c=a(l),u=Array.isArray(y.responsiveVariants)&&y.responsiveVariants.length>0||y.responsiveVariants===!0,o=j==null?void 0:j[a$1],d=[];if(typeof c=="object"&&u)for(let[T,X]of Object.entries(c)){let ae=s[X];if(T==="initial"){o=X;continue}Array.isArray(y.responsiveVariants)&&!y.responsiveVariants.includes(T)||(d=P(T,ae,d,t));}let $=c!=null&&typeof c!="object"?c:a(o),h=s[$||"false"];return typeof d=="object"&&typeof t=="string"&&d[t]?x(d,h):d.length>0?(d.push(h),t==="base"?d.join(" "):d):h},p=()=>g$1?Object.keys(g$1).map(a=>H(a,g$1)):null,ee=(a,r)=>{if(!g$1||typeof g$1!="object")return null;let t=new Array;for(let i in g$1){let s=H(i,g$1,a,r),l=a==="base"&&typeof s=="string"?s:s&&s[a];l&&(t[t.length]=l);}return t},I={};for(let a in f)f[a]!==void 0&&(I[a]=f[a]);let J=(a,r)=>{var i;let t=typeof(f==null?void 0:f[a])=="object"?{[a]:(i=f[a])==null?void 0:i.initial}:{};return {...j,...I,...t,...r}},L=(a=[],r)=>{let t=[];for(let{class:i,className:s,...l}of a){let c=!0;for(let[u,o]of Object.entries(l)){let d=J(u,r)[u];if(Array.isArray(o)){if(!o.includes(d)){c=!1;break}}else {let $=h=>h==null||h===!1;if($(o)&&$(d))continue;if(d!==o){c=!1;break}}}c&&(i&&t.push(i),s&&t.push(s));}return t},te=a=>{let r=L(M,a);if(!Array.isArray(r))return r;let t={};for(let i of r)if(typeof i=="string"&&(t.base=O(t.base,i)(y)),typeof i=="object")for(let[s,l]of Object.entries(i))t[s]=O(t[s],l)(y);return t},ne=a=>{if(v.length<1)return null;let r={};for(let{slots:t=[],class:i,className:s,...l}of v){if(!b(l)){let c=!0;for(let u of Object.keys(l)){let o=J(u,a)[u];if(o===void 0||(Array.isArray(l[u])?!l[u].includes(o):l[u]!==o)){c=!1;break}}if(!c)continue}for(let c of t)r[c]=r[c]||[],r[c].push([i,s]);}return r};if(!b(V)||!S){let a={};if(typeof N=="object"&&!b(N))for(let r of Object.keys(N))a[r]=t=>{var i,s;return O(N[r],ee(r,t),((i=te(t))!=null?i:[])[r],((s=ne(t))!=null?s:[])[r],t==null?void 0:t.class,t==null?void 0:t.className)(y)};return a}return O(k,p(),L(M),f==null?void 0:f.class,f==null?void 0:f.className)(y)},K=()=>{if(!(!g$1||typeof g$1!="object"))return Object.keys(g$1)};return w.variantKeys=K(),w.extend=e,w.base=k,w.slots=N,w.variants=g$1,w.defaultVariants=j,w.compoundSlots=v,w.compoundVariants=M,w},oe=n=>(b,e)=>{let V=e?g(n,e):n;return e!=null&&e.twMergeFn?V.twMergeFn=e.twMergeFn:n.twMergeFn&&!V.twMergeFn&&(V.twMergeFn=n.twMergeFn),ce(b,V)};export{O as cn,A as cnBase,oe as createTV,ie as defaultConfig,ce as tv,q as voidEmpty};
